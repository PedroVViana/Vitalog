rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to validate FoodEntry structure
    function isValidFoodEntry() {
      let entry = request.resource.data;
      return entry.keys().hasAll(['id', 'mealType', 'createdAt', 'type', 'tags']) &&
             entry.mealType is string &&
             entry.createdAt is string &&
             entry.type is string &&
             entry.tags is list &&
             (!entry.keys().hasAny(['text']) || entry.text is string) &&
             (!entry.keys().hasAny(['imageUrl']) || entry.imageUrl is string) &&
             (!entry.keys().hasAny(['audioUrl']) || entry.audioUrl is string) &&
             (!entry.keys().hasAny(['observation']) || entry.observation is string) &&
             (!entry.keys().hasAny(['dietId']) || entry.dietId is string);
    }
    
    // Helper function to validate Diet structure
    function isValidDiet() {
      let diet = request.resource.data;
      return diet.keys().hasAll(['id', 'name', 'isActive']) &&
             diet.name is string &&
             diet.isActive is bool &&
             (!diet.keys().hasAny(['description']) || diet.description is string) &&
             (!diet.keys().hasAny(['startDate']) || diet.startDate is string) &&
             (!diet.keys().hasAny(['endDate']) || diet.endDate is string) &&
             (!diet.keys().hasAny(['notes']) || diet.notes is string) &&
             (!diet.keys().hasAny(['attachmentUrl']) || diet.attachmentUrl is string) &&
             (!diet.keys().hasAny(['attachmentType']) || diet.attachmentType in ['image', 'pdf']);
    }
    
    // Helper function to validate Habit structure
    function isValidHabit() {
      let habit = request.resource.data;
      return habit.keys().hasAll(['id', 'name', 'frequencyPerWeek', 'isArchived', 'createdAt']) &&
             habit.name is string &&
             habit.frequencyPerWeek is int &&
             habit.isArchived is bool &&
             habit.createdAt is string &&
             (!habit.keys().hasAny(['colorHex']) || habit.colorHex is string);
    }
    
    // Helper function to validate Entry structure
    function isValidEntry() {
      let entry = request.resource.data;
      return entry.keys().hasAll(['id', 'habitId', 'createdAt', 'type', 'tags']) &&
             entry.habitId is string &&
             entry.createdAt is string &&
             entry.type is string &&
             entry.tags is list &&
             (!entry.keys().hasAny(['text']) || entry.text is string) &&
             (!entry.keys().hasAny(['imageUrl']) || entry.imageUrl is string) &&
             (!entry.keys().hasAny(['audioUrl']) || entry.audioUrl is string) &&
             (!entry.keys().hasAny(['mood']) || entry.mood is int) &&
             (!entry.keys().hasAny(['energy']) || entry.energy is int);
    }
    
    // Helper function to validate MealCategory structure
    function isValidMealCategory() {
      let category = request.resource.data;
      return category.keys().hasAll(['id', 'name', 'mealType', 'isArchived', 'createdAt']) &&
             category.name is string &&
             category.mealType is string &&
             category.isArchived is bool &&
             category.createdAt is string &&
             (!category.keys().hasAny(['colorHex']) || category.colorHex is string);
    }
    
    // Users collection - users can only read/write their own profile
    match /users/{userId} {
      allow read, write: if isOwner(userId);
      
      // Food Entries subcollection
      match /foodEntries/{entryId} {
        allow read, write: if isOwner(userId) && isValidFoodEntry();
        allow create: if isOwner(userId) && isValidFoodEntry();
        allow update: if isOwner(userId) && isValidFoodEntry();
        allow delete: if isOwner(userId);
      }
      
      // Diets subcollection
      match /diets/{dietId} {
        allow read, write: if isOwner(userId) && isValidDiet();
        allow create: if isOwner(userId) && isValidDiet();
        allow update: if isOwner(userId) && isValidDiet();
        allow delete: if isOwner(userId);
      }
      
      // Habits subcollection
      match /habits/{habitId} {
        allow read, write: if isOwner(userId) && isValidHabit();
        allow create: if isOwner(userId) && isValidHabit();
        allow update: if isOwner(userId) && isValidHabit();
        allow delete: if isOwner(userId);
      }
      
      // Entries subcollection (for habits)
      match /entries/{entryId} {
        allow read, write: if isOwner(userId) && isValidEntry();
        allow create: if isOwner(userId) && isValidEntry();
        allow update: if isOwner(userId) && isValidEntry();
        allow delete: if isOwner(userId);
      }
      
      // Meal Categories subcollection
      match /mealCategories/{categoryId} {
        allow read, write: if isOwner(userId) && isValidMealCategory();
        allow create: if isOwner(userId) && isValidMealCategory();
        allow update: if isOwner(userId) && isValidMealCategory();
        allow delete: if isOwner(userId);
      }
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

